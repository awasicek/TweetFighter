package com.awasicek;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URL;
import java.net.URLEncoder;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.HttpsURLConnection;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import javafx.util.Pair;
/*
 * Intentionally not using a library such as twitter4j so as to practice and learn implementing
 * oAuth and web API implementation in Java. Also note that some variable names do not follow
 * the standard camel casing pattern but instead follow Twitter's snake casing so as to provide
 * maximum readability when following Twitter's API documentation.
 * 
 * Also note, currently using only the bearer authorization method, not the full oAuth method
 * which is fine for just fetching tweets but leaving the oAuth code in here in case I want to
 * expand the functionality to other Twitter API endpoints that require it.
 */

// https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request
public class TwitterService {

	private final String bearerToken = "AAAAAAAAAAAAAAAAAAAAADNW8QAAAAAAAJPEvrSEXtp%2FbJ4prsf%2FSLGaOOs%3DR9QWffmS0ZGDYuR11GejDPcxVqcjQ7Sd9wpyohT4GD4uwNL2jJ";

	
	// TODO put in environment/safer/more appropriate location
	
	public static String screenName = "";

	private final String consumerSecret = "b62DC2teUyf9eLNYFOpuWOXs7rh6VVPdYAtsv1shVZfLzExXRb"; 

	private final String tokenSecret = "tH4VhjuNGxnpKwotARJvO9TiFbRYM2d2uzVoCHbemGfAb";
	
	public void encode() 
	{
		
		//String forBearerToken = oauth_consumer_key + ":" + twitterSecretApiKey;
		
		//System.out.println("BASE 64 ENCODED:\n" + Base64.getEncoder().encodeToString(forBearerToken.getBytes()));	
	}
	
	public void connect() 
	{
		// SAMPLE
		//GET https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=twitterapi&count=2
		
		// BUILD AUTHORIZATION HEADER
		// https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request
		// Collecting parameters
		// You should be able to see that the header contains 7 key/value pairs, where the keys all begin with the string “oauth_”. 
		// For any given Twitter API request, collecting these 7 values and creating a similar header will allow you to specify authorization for the request. 
		// The 7 parameters are: (1) consumer key (oauth_consumer_key), (2) nonce (oauth_nonce), (3) signature (oauth_signature), (4) signature method (oauth_signature_method),
		// (5) timestamp (oauth_timestamp), (6) token (oauth_token), and (7) version (oauth_version).
		
		// (1) Consumer key
		// The oauth_consumer_key identifies which application is making the request. Obtain this value from the settings page for your Twitter app in the developer portal.
		String oauth_consumer_key = "YDIhLsKqaZ1beZoGagyWJ4en6"; 
		
		// (2) Nonce
 		// The oauth_nonce parameter is a unique token your application should generate for each unique request. 
		// Twitter will use this value to determine whether a request has been submitted multiple times. 
		// The value for this request was generated by base64 encoding 32 bytes of random data, and stripping out all non-word characters, 
		// but any approach which produces a relatively random alphanumeric string should be OK here.
		String oauth_nonce = String.valueOf(System.currentTimeMillis());
		
		// (3) Signature 
		// See below.
		
		// (4) Signature method
		// The oauth_signature_method used by Twitter is HMAC-SHA1. This value should be used for any authorized request sent to Twitter’s API.
		String oauth_signature_method = "HMAC-SHA1";
		
		// (5) Timestamp
		// The oauth_timestamp parameter indicates when the request was created. This value should be the number of seconds since the Unix epoch 
		// at the point the request is generated, and should be easily generated in most programming languages. Twitter will reject requests 
		// which were created too far in the past, so it is important to keep the clock of the computer generating requests in sync with NTP.
		String oauth_timestamp = getCurrentTimeAsString();
		
		// (6) Token
		// The oauth_token parameter typically represents a user’s permission to share access to their account with your application. 
		// There are a few authentication requests where this value is not passed or is a different form of token, but those are covered 
		// in detail in Obtaining access tokens. For most general-purpose requests, you will use what is referred to as an access token.
		String oauth_token = "4813009224-5SgC80Kokz1jF6Nc9HQKlpMucoSD13EhGEiACVl"; 
		
		// (7) Version
		// The oauth_version parameter should always be 1.0 for any request sent to the Twitter API.
		String oauth_version = "1.0";
		
		
		// CREATING SIGNATURE
		// https://developer.twitter.com/en/docs/basics/authentication/guides/creating-a-signature.html
		// The oauth_signature parameter contains a value which is generated by running all of the other request parameters and two secret values 
		// through a signing algorithm. The purpose of the signature is so that Twitter can verify that the request has not been modified in transit, 
		// verify the application sending the request, and verify that the application has authorization to interact with the user’s account.

		// To produce a signature, start by determining the HTTP method and URL of the request.
		String httpMethod = "GET";
		String requestUrl = "https://api.twitter.com/1.1/statuses/user_timeline.json";

		// Next, gather all of the parameters included in the request. There are two such locations for these additional 
		// parameters - the URL (as part of the querystring) and the request body.
		// In the HTTP request the parameters are URL encoded, but you should collect the raw values. 
		// In addition to the request parameters, every oauth_* parameter needs to be included in the signature, so collect those too.
		List<Pair<String, String>>paramsList = new ArrayList<Pair<String, String>>();
		
		// String screenName = "realDonaldTrump";
		String count = "20";
		paramsList.add(new Pair<String, String>("screen_name", screenName));
		paramsList.add(new Pair<String, String>("count", count));
		paramsList.add(new Pair<String, String>("oauth_consumer_key", oauth_consumer_key));
		paramsList.add(new Pair<String, String>("oauth_nonce", oauth_nonce));
		paramsList.add(new Pair<String, String>("oauth_signature_method", oauth_signature_method));
		paramsList.add(new Pair<String, String>("oauth_timestamp", oauth_timestamp));
		paramsList.add(new Pair<String, String>("oauth_token", oauth_token));
		paramsList.add(new Pair<String, String>("oauth_version", oauth_version));
		
		// These values need to be encoded into a single string which will be used later on. The process to build the string is very specific:

		//	Percent encode every key and value that will be signed.
		//	Sort the list of parameters alphabetically by encoded key.
		//	For each key/value pair:
		//	Append the encoded key to the output string.
		//	Append the ‘=’ character to the output string.
		//	Append the encoded value to the output string.
		//	If there are more key/value pairs remaining, append a ‘&’ character to the output string.

		List<Pair<String, String>> encodedParamsList = new ArrayList<Pair<String, String>>();
		
		for (Pair<String, String>p : paramsList) 
		{
			try {
				encodedParamsList.add(new Pair<String, String>(URLEncoder.encode(p.getKey(), "UTF-8"), URLEncoder.encode(p.getValue(), "UTF-8")));
			} catch (UnsupportedEncodingException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		Collections.sort(encodedParamsList, new AlphabetizePairsComparator()); // alphabetize
		
		StringBuilder parameterString = new StringBuilder();
		
		for(int i = 0; i < encodedParamsList.size(); i++)
		{
			if(i > 0) 
			{
				parameterString.append("&");
			}
			parameterString.append(paramsList.get(i).getKey() + "=" + paramsList.get(i).getValue());
		}	
				
		// Creating the signature base string
		// The three values collected so far must be joined to make a single string, from which the signature will be generated. This is called the signature base string by the OAuth specification.

		// To encode the HTTP method, base URL, and parameter string into a single string:

		String computedSignature;
		String oauth_signature = "";
				
		// Convert the HTTP Method to uppercase and set the output string equal to this value.
		// Append the ‘&’ character to the output string.
		// Percent encode the URL and append it to the output string.
		// Append the ‘&’ character to the output string.
		// Percent encode the parameter string and append it to the output string.
		try {
			String signatureBaseString = URLEncoder.encode(httpMethod, "UTF-8") + "&" + URLEncoder.encode(requestUrl, "UTF-8") 
										  + "&" + URLEncoder.encode(parameterString.toString(), "UTF-8");
		    
			//System.out.println("\nSignature Base String:\n" + signatureBaseString);
			
			// Signing Key
			// The signing key is a combination of the Consumer secret and OAuth token secret. Both of these values need to be combined to form a signing key which 
			// will be used to generate the signature. The signing key is simply the percent encoded consumer secret, followed by an ampersand character ‘&’, 
			// followed by the percent encoded token secret.
			String signingKey = URLEncoder.encode(consumerSecret, "UTF-8") + "&" + URLEncoder.encode(tokenSecret, "UTF-8");

		    
			// Calculating the signature
			// Finally, the signature is calculated by passing the signature base string and signing key to the HMAC-SHA1 hashing algorithm. 
			// The details of the algorithm are explained hash_hmac function.
			// The output of the HMAC signing function is a binary string. This needs to be base64 encoded to produce the signature string.
		    computedSignature =  computeSignature(signatureBaseString, signingKey); // binary string
		    
		    oauth_signature = URLEncoder.encode(computedSignature, "UTF-8");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		// BUILD HEADER STRING
		// To build the header string, imagine writing to a string named DST.

		// Append the string “OAuth ” (including the space at the end) to DST.
		// For each key/value pair of the 7 parameters listed above:
		// Percent encode the key and append it to DST.
		// Append the equals character ‘=’ to DST.
		// Append a double quote ‘”’ to DST.
		// Percent encode the value and append it to DST.
		// Append a double quote ‘”’ to DST.
		// If there are key/value pairs remaining, append a comma ‘,’ and a space ‘ ‘ to DST.
		// String authorizationHeader = "OAuth oauth_consumer_key=\"" + oauth_consumer_key + "\", oauth_nonce=\"" + oauth_nonce +
		//							 "\", oauth_signature=\"" + oauth_signature + "\", oauth_signature_method=\"" + 
		//							 oauth_signature_method + "\", oauth_timestamp=\"" + oauth_timestamp + "\", oauth_token=\"" + 
		//							 oauth_token + "\", oauth_version=\"" + oauth_version + "\"";
		
		String authorizationHeader = "OAuth oauth_consumer_key=\"" + oauth_consumer_key + "\", oauth_token=\"" + oauth_token +
									 "\", oauth_signature_method=\"" + oauth_signature_method + "\", oauth_timestamp=\"" +
									 oauth_timestamp + "\", oauth_nonce=\"" + oauth_nonce + "\", oauth_version=\"" +
									 oauth_version + "\", oauth_signature=\"" + oauth_signature + "\"";
		
		// Authorization: OAuth oauth_consumer_key="YDIhLsKqaZ1beZoGagyWJ4en6",oauth_token="4813009224-5SgC80Kokz1jF6Nc9HQKlpMucoSD13EhGEiACVl",
		//		oauth_signature_method="HMAC-SHA1",oauth_timestamp="1535232519",oauth_nonce="sdRP0e9Tepr",oauth_version="1.0",
		//		oauth_signature="nGvKGYSDnnHZyZrwGhYYkU7yb84%3D"
		
		
		System.out.println("\nAuthorization Header:\n" + authorizationHeader);
		
		String urlWithQueryStringParams = requestUrl + "?" + "screen_name" + "=" + screenName + "&" + "count" + "=" + count;
		
		// sample: grant_type=client_credentials&other_thing=another_thing
		// String requestBody = "screen_name" + "=" + screenName + "&" + "count" + "=" + count;
		
		String bearerAuthorization = "Bearer " + bearerToken;
		

		
		// MAKING THE CALL TO TWITTER		
		
		
		URL url = null;
		HttpsURLConnection connection = null;
		try {
			url = new URL(urlWithQueryStringParams);
			//url = new URL(urlWithQueryStringParams);
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			connection = (HttpsURLConnection) url.openConnection();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			connection.setRequestMethod(httpMethod);
		} catch (ProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		connection.setRequestProperty("User-Agent", "Studen App Tweet Fighter");
		connection.setRequestProperty("Authorization", bearerAuthorization);
		//connection.setRequestProperty("Authorization", authorizationHeader);
				
		connection.setConnectTimeout(5000);
		
		try {
			connection.connect();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		// int responseCode = 0;
		// try {
		//	responseCode = connection.getResponseCode();
		// } catch (IOException e) {
		//	// TODO Auto-generated catch block
		//	e.printStackTrace();
		// }
		//
		// System.out.println("\nRESPONSE CODE:\n" + responseCode);
		
		String input;
		StringBuffer content = new StringBuffer();
		try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())))
		{
			while((input = in.readLine()) != null) {
				content.append(input);
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		// prepend and append so output from Twitter is valid JSON 
		content.insert(0, "{\"array\":");
		content.append("}");
		
		System.out.println("\nRESPONSE:\n" + content.toString());

		
		JSONParser parser = new JSONParser();
		JSONObject json = null;
		try {
			Object obj = parser.parse(content.toString());
			json = (JSONObject) obj;
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		JSONArray jsonArray = (JSONArray) json.get("array");
		
		for(int i = 0; i < jsonArray.size(); i++)
		{
			JSONObject j = (JSONObject) jsonArray.get(i);
			String tweet = (String) j.get("text");
			Tweet.tweets.add(tweet);
			System.out.println(tweet);
		}
		
		
		connection.disconnect();
		//System.exit(0);
		}
	
	private String getCurrentTimeAsString() {
	    long ms = System.currentTimeMillis();
	    return String.valueOf(ms / 1000);
	}
	
	private static String computeSignature(String baseString, String keyString) throws GeneralSecurityException, UnsupportedEncodingException, Exception 
	{
	    SecretKey secretKey = null;

	    byte[] keyBytes = keyString.getBytes();
	    secretKey = new SecretKeySpec(keyBytes, "HmacSHA1");

	    Mac mac = Mac.getInstance("HmacSHA1");

	    mac.init(secretKey);

	    byte[] text = baseString.getBytes();

	    return new String(Base64.getEncoder().encode((mac.doFinal(text)))).trim();
	}
}

class AlphabetizePairsComparator implements Comparator<Pair<String, String>>
{

	// compares the keys of each pair and returns the numeric result of the lexicographical comparison
	@Override
	public int compare(Pair<String, String> pair1, Pair<String, String> pair2) {
		String key1 = pair1.getKey();
		String key2 = pair2.getKey();
		// evaluate key1's alphabetical ordering compared to key2 (negative if before key2, zero if equal to key2, positive if after key2)
		int comparisonResult = key1.compareTo(key2);
		return comparisonResult;
	}
	
}